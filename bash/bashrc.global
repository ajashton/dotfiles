# == ENVIRONMENT ===============================================================

export EDITOR=vim
export GREP_COLOR="1;33"
export PATH=$PATH:/usr/local/bin:$HOME/bin

shopt -s checkwinsize

# let autocomplete work with sudo
complete -cf sudo

# ---- History -----------------------------------------------------------------

shopt -s histappend
export PROMPT_COMMAND="history -w;$PROMPT_COMMAND"
export HISTCONTROL=erasedups
export HISTFILE=$HOME/.bash/history
export HISTSIZE=50000
export HISTIGNORE='&:ls:cd ~:cd ..:[bf]g:exit:h:history'

# ---- Shell Prompt ------------------------------------------------------------

# Functions to tell me whether I am in a git or svn working copy, + which branch
parse_git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(git::\1)/'
}
parse_svn_branch() {
  parse_svn_url | sed -e 's#^'"$(parse_svn_repository_root)"'##g' | awk -F / '{print "(svn::"$1 "/" $2 ")"}'
}
parse_svn_url() {
  svn info 2>/dev/null | grep -e '^URL*' | sed -e 's#^URL: *\(.*\)#\1#g '
}
parse_svn_repository_root() {
  svn info 2>/dev/null | grep -e '^Repository Root:*' | sed -e 's#^Repository Root: *\(.*\)#\1\/#g '
}

# The prompt itself
if [ $TERM = 'dumb' ] ; then
    # Vim: No color, no unicode.
    export PS1="\n[ \u@\h : \w \$(parse_git_branch)\$(parse_svn_branch) ]\n> "
elif [ $TERM = 'mrxvt' ] ; then
    # Mrxvt supports color, but not unicode.
    # export PS1="[\h] \W > "
    export PS1="\n[ \[\033[00m\]\u@\h : \[\033[01;34m\]\w \[\033[31m\]\$(parse_git_branch)\$(parse_svn_branch)\[\033[00m\] ]\n> "
else
    # Default: Full-color in unicode. PS1 looks like this:
    # ┌─[ aj@macbook : ~/src/dotfiles (git::master) ]
    # └─╼ 
    export PS1="\n┌─[ \[\033[00m\]\u@\h : \[\033[01;34m\]\w \[\033[31m\]\$(parse_git_branch)\$(parse_svn_branch)\[\033[00m\] ]\n└─╼ "
fi

# == ALIASES ===================================================================

# ---- Alternatives ------------------------------------------------------------

test -x /usr/bin/colordiff && alias diff='colordiff'
test -x /usr/bin/most && alias less='most'
test -x /usr/bin/pacman-color && alias pacman='pacman-color'
alias vi='vim'

# ---- Preferred Default Options -----------------------------------------------

alias cp='cp -v'
alias df='df -h'
alias grep='grep --color=auto'
alias mkdir='mkdir -p'
alias mv='mv -vi'
alias rm='rm -v'
alias vlc='vlc --extraintf http'

# ---- Shortcuts  --------------------------------------------------------------

# ls
alias ls='ls -F --color=auto'            # a couple good defaults
alias l='ls -F --color=auto'             # 50% less typing!
alias ll='ls -Fhl --color=auto'          # long list
alias la='ls -AFh --color=auto'          # list all
alias lla='ls -AFl --color=auto'         # long list all
alias lr='ls -FR --color=auto'           # list recursive
alias llr='ls -FlR --color=auto'         # long list recursive
alias lx='ls -lXB --color=auto'          # sort by extension
alias lm='ls -Fl --color=always | most'  # pipe to most, with color

# cd
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'

# drush
alias dcc='druch cache-clear all'
alias dfu='drush features-update'

# power management
alias shutdown='sudo shutdown -h now'
alias reboot='sudo shutdown -r now'
alias suspend='sudo pm-suspend'
alias hibernate='sudo pm-hibernate'


alias ffeh='feh -FZ'

alias mp3name='eyeD3 --rename="%n. %t"'

alias otf2ttf="fontforge -script $HOME/bin/otf2ttf.sh"


# == FUNCTIONS =================================================================

# Check which distro we're on & set appropriat daemon location
if   grep -i arch /proc/version ;   then DAEMON_DIR=/etc/rc.d
elif grep -i ubuntu /proc/version ; then DAEMON_DIR=/etc/init.d
# Control daemons slightly more easily & consistently
# TODO: bash completion configuration
restart() { sudo $DAEMON_DIR/$1 restart; }
start()   { sudo $DAEMON_DIR/$1 start; }
stop()    { sudo $DAEMON_DIR/$1 stop; }

# ESRI shapefiles are a series of files with the same basename but different 
# file extensions. This function makes moving/copying them much easier.
# EG to rename foo.shp (et al) to bar.shp (et al), do:
# shpmv foo bar
# Note that these are extremely fragile and easily broken by, eg. spaces.

shpmv() {
  for infile in ${1}*; do
    mv $infile `echo $infile | sed "s/$1/$2/"`
  done
}

shpcp() {
  for infile in ${1}*; do
    cp $infile `echo $infile | sed "s/$1/$2/"`
  done
}

# Follow copied and moved files to destination directory (courtesy jwr)
follow() { [ -d "$1" ] && cd "$1" || cd "$(dirname "$1")"; }
cpf() { cp "$@" && follow "$_"; }
mvf() { mv "$@" && follow "$_"; }

# Make one or more directories, and cd to the last one in the list
mcd() { mkdir -p "$@" && goto "$_"; }

# TODO: Make these more robust, ie, work on files in subdirs
function hide() { for file in "$@"; do mv -i "$file" ".$file"; done }

function unhide() { for file in "$@"; do mv -i "$file" "`echo $file | sed 's/^\.//'`"; done }

function cnik {
  # compiles a Cascadenik file into a map.xml
  # @TODO: 
  #   - option for custom output file
  #   - option for custom output directory (-d)
  
  outfile=`basename $1 .mml`.map.xml
  cascadenik-compile.py $1 > $outfile
}

function xt() {
  # xt = eXTract, a wrapper to extract many different archive formats
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xvjf $1     ;;
      *.tar.gz)    tar xvzf $1     ;;
      *.bz2)       bunzip2 $1      ;;
      *.rar)       unrar x $1      ;;
      *.gz)        gunzip $1       ;;
      *.tar)       tar xvf $1      ;;
      *.tbz2)      tar xvjf $1     ;;
      *.tgz)       tar xvzf $1     ;;
      *.zip)       unzip $1        ;;
      *.Z)         uncompress $1   ;;
      *.7z)        7z x $1         ;;
      *)           echo "'$1' cannot be extracted via >extract<" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

